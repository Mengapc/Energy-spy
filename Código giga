#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <SPI.h>
#include <Ethernet.h>

#define endereco  0x27
#define colunas   16
#define linhas    2

LiquidCrystal_I2C lcd(endereco, colunas, linhas);

//Definicoes de IP, mascara de rede e gateway
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192,168,15,201);          //Define o endereco IP
IPAddress gateway(192,168,15,1);     //Define o gateway
IPAddress subnet(255, 255, 255, 0); //Define a máscara de rede
 
// Inicializa o servidor web na porta 80
EthernetServer server(80);
// Inicializa Client
EthernetClient clientEnvio;

// Dados do Serviço
int    HTTP_PORT   = 80;
String HTTP_METHOD = "POST";
char   HOST_NAME[] = "energyspy.azurewebsites.net";
String PATH_NAME   = "/enviar_leitura/";
int    COD_CLIENTE = 1;

// Definição das varíaveis de sensores
float tensao = 127;
float corrente = 0;
float potencia = 0;

// Frequencia de atualização do servidor
const long interval = 30 * 1000; // ms
unsigned long previousMillis = 0;  // último envio ao serviço cloud

void setup()
{
  lcd.init();
  lcd.backlight();
  lcd.clear();

  lcd.print("Corrente: variável");
  delay(500);
  lcd.setCursor(0, 1);
  lcd.print("Potencia: variável");
  delay(500);

  lcd.noBacklight();
  delay(2000);
  lcd.backlight();
  delay(2000);
  
  Serial.begin(9600);
  while (!Serial) {
  ; // wait for serial port to connect. Needed for Leonardo only
  }
  //Inicializa a interface de rede
  if (Ethernet.begin(mac) == 0) {
    Serial.println("Failed to configure Ethernet using DHCP");
    Ethernet.begin(mac, ip, gateway, subnet);
  } else {
    Serial.println("DHCP OK");
    Serial.print("IP: ");
    for (byte thisByte = 0; thisByte < 4; thisByte++) {
      // print the value of each byte of the IP address:
      Serial.print(Ethernet.localIP()[thisByte], DEC);
      Serial.print("."); 
    }
  }
  server.begin();
}
 
void loop() {

  //Aguarda conexao do browser
  EthernetClient client = server.available();
  if (client) {
    Serial.println("new client");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\r\n' && currentLineIsBlank) {
          // send a standard http response header
          client.println("HTTP/1.1 200 OK");
          client.println("Content-Type: text/html");
          client.println("Connection: close");
          client.println("Refresh: 2"); //Recarrega a pagina a cada 2seg
          client.println();
          client.println("<!DOCTYPE HTML>");
          client.println("<html>");
          //Configura o texto e imprime o titulo no browser
          client.print("<font color=#FF0000><b><u>");
          client.print("Envio de informacoes pela rede utilizando Arduino");
          client.print("</u></b></font>");
          client.println("<br />");
          client.println("<h3>Ethernet</h3>");
          client.print("<b>IP:</b>");
          for (byte thisByte = 0; thisByte < 4; thisByte++) {
            // print the value of each byte of the IP address:
            client.print(Ethernet.localIP()[thisByte], DEC);
            client.print("."); 
          }
          client.println("<br/>");
          client.print("<b>Default Gateway:</b>");
          for (byte thisByte = 0; thisByte < 4; thisByte++) {
            // print the value of each byte of the IP address:
            client.print(Ethernet.gatewayIP()[thisByte], DEC);
            client.print("."); 
          }
          client.println("<br/>");
          client.println("</html>");
          break;
        }
        if (c == '\r\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } 
        else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
  }
  // Leitura de sensores e envio para cloud
  unsigned long currentMillis = millis();
  if ((currentMillis - previousMillis) > interval) {
    previousMillis = currentMillis;
    lerSensores();
    Serial.println(corrente);
    Serial.println(potencia);
    enviarDados();
  }
}

void lerSensores() {
  corrente = random(2, 10);
  potencia = tensao * corrente;
}

void enviarDados() {
  if(clientEnvio.connect(HOST_NAME, HTTP_PORT)) {
    Serial.println("Connected to server");
  } else {
    Serial.println("connection failed");
    return;
  }
  String postContent =  "{\r\n";
  postContent.concat("   \"cod_cliente\": ");
  postContent.concat(COD_CLIENTE);
  postContent.concat(",\r\n");
  postContent.concat("   \"corrente\": ");
  postContent.concat(corrente);
  postContent.concat(",\r\n");
  postContent.concat("   \"potencia\": ");
  postContent.concat(potencia);
  postContent.concat(",\r\n");
  postContent.concat("   \"tensao\": ");
  postContent.concat(tensao);
  postContent.concat("\r\n}\r\n");

  String postRequest = "POST ";
  postRequest.concat(PATH_NAME);
  postRequest.concat(" HTTP/1.1\r\n");
  postRequest.concat("Host: ");
  postRequest.concat(HOST_NAME);
  postRequest.concat("\r\n");
  postRequest.concat("User-Agent: Arduino/1.0\r\n");
  postRequest.concat("Connection: close\r\n"); 
  postRequest.concat("Content-Type: application/json\r\n");
  postRequest.concat("Content-Length: ");
  postRequest.concat(postContent.length());
  postRequest.concat("\r\n");
  postRequest.concat("\r\n");
  postRequest.concat(postContent);
  postRequest.concat("\r\n");
  clientEnvio.println(postRequest);
  clientEnvio.println();
  Serial.println(postRequest);
  delay(2000);
  int i = 0;
  while ((clientEnvio.available()) && (i < 1024)) {
    i++;
    char c = clientEnvio.read();
    Serial.print(c);
  }
  Serial.println("");

  if (!clientEnvio.connected()) {
    // if the server's disconnected, stop the client:
    Serial.println("disconnected");
  }
  Serial.println("closing");
  clientEnvio.stop();

}
